Design and Analysis of Two Algorithms for Generating Permutations of a Set
	by Ryan Bernstein
	   Ruben Niculcea
	   Levi Schoen

CS 350
Winter 2015

Project Abstract:
	A formal mathematical analysis of two algorithms-Heap's,
	 and Steinhaus-Johnson-Trotter -for generating permutations 
	of a set. Implementation, execution  and analysis of space 
	and time performance of these two algorithms in Python. 
	Additional consideration is given to the nature of generating 
	permutations, and how these two algorithms differ in solving that problem.

Area of Analysis:
	Talk about the general class of generating permutations.
	Different methods: loopless, recursive, adjacent exchanges, factorial counting
	The last point is a simple rehash of R. Sedgewick's paper.....
	Problem Bottlenecks 

Methods:
	Heap's:
		Explanation:
			// WIP
			Heap's algorithm is a permutation generation algorithm. It works by recursively calling itself and at the end of each recursion is swaps either the first or the 

			// Wikipedia
			First we set a counter i  to 1. Now we perform the following steps repeatedly, until i  is bigger than N. We use the algorithm to generate the (N − 1)! permutations of the first N − 1 elements, adjoining the last element to each of these. This generates all of the permutations that end with the last element. Then if N is odd, we switch the first element and the last one, while if N is even we can switch the i th element and the last one (there is no difference between N even and odd in the first iteration). We add one to the counter i and repeat. In each iteration, the algorithm will produce all of the permutations that end with the element that has just been moved to the "last" position.

		Implemenation:
			algorithm Heaps(n, A):
			//Outputs all the permutations of A using Heap's algorithm
			//Input: A is a set, n is the cardinality of the set A
			//Output: The permutations of A
	    if n = 1 then
	          output(A)
	    else
	        for i ← 1 to n
	            Heaps(n - 1, A)
	            if n is odd then
	                j ← 1
	            else
	                j ← i
	            swap(A[j], A[n])
	            i ← i + 1

		Run time
		Correctness
		Termination
	SJT:
		Explanation:
		Implemenation 
		Run time
		Correctness
		Termination
Results & Analysis:
	Heap's:
		Space
		Time
		Additional Notes
	SJT:
		Space
		Time
		Additional Notes
		
Conclusion:
	Time and space trade-off's of the two, specific applications where one might be better than the other, or is one generally better? 
	Limitations

References:
	General:
		Robert Sedgewick, 1977, ACM, "Permutation Generation Methods
		Writing the paper (http://www.owlnet.rice.edu/~cainproj/courses/comp482/comp482PaperGuide_F07.pdf)
	SJT:
	http://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm
	http://www.cut-the-knot.org/Curriculum/Combinatorics/JohnsonTrotter.shtml
	http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Levitin/PDF/L07-PermutationsSubsets.pdf

	Heap's:
		http://en.wikipedia.org/wiki/Heap%27s_algorithm

Notes: Extra swap for Heap's 
