Design and Analysis of Two Algorithms for Generating Permutations of a Set
	by Ryan Bernstein
	   Ruben Niculcea
	   Levi Schoen

CS 350
Winter 2015

Project Abstract:
	A formal mathematical analysis of two algorithms-Heap's,
	and Steinhaus-Johnson-Trotter -for generating permutations 
	of a set. Implementation, execution  and analysis of space 
	and time performance of these two algorithms in Python. 
	Additional consideration is given to the nature of generating 
	permutations, and how these two algorithms differ in solving that problem.

Area of Analysis:
	The application and study of algorithms in the field of 				combinatorics-particularly permutation generation-is an exciting area of 		theoretical study, albeit with dull practical outcomes and application. This is 	due to 	the fact, that as far as mathematician's and computer science have 		ascertained, distinct and complete permutation generation of a set is a problem 	that is NP hard. There has yet to be an algorithm that solves this problem with 	even less than 	O(n!) time complexity. The differences in the algorithms are 		wrinkles that allow for more space efficient computations, or that merely exist to 	show the cleverness of the designer with a novel application of a design pattern 	to the problem.

	Algorithms for this problem fall into two camps: those based off of 			exchanging one element for another element-with each bubbling generating a new and 	unique subset-and those that do something else, such as nested cycling, sort 		cycling, or random set generation-which has actual utility in cases where it's 		more important that a given subset generated is unique as opposed to generating 	all such subset. Our first algorithm, Heap's Algorithm, is a recursive twist on 	the exchange method. The second, Steinhaus-Johnson-Trotter, is an adjacent 		exchange method implemented iteratively with one loop structure-though there are 	recursive versions of this algorithm as well.

	The retractable nature of this problem has lead to the discovery and refinement of 	more efficient combinatorial search optimization algorithms, with emphasis on the 	use of backtracking and mathematical programming, most notably being the solution 	to the four coloring graph problem.  

	
Methods:
	Heap's:
		Explanation:
			// WIP
			Heap's algorithm is a permutation generation algorithm. It works
			by recursively calling itself and at the end of each recursion is
			swaps either the first or the last element.

			// Wikipedia
			First we set a counter i  to 1. Now we perform the following steps 
			repeatedly, until i  is bigger than N. We use the algorithm to 	
			generate the (N − 1)! permutations of the first N − 1 elements, 
			adjoining the last element to each of these. This generates all of 
			the permutations that end with the last element. Then if N is odd, 
			we switch the first element and the last one, while if N is even 
			we can switch the i th element and the last one (there is no 
			difference between N even and odd in the first iteration). We add 
			one to the counter i and repeat. In each iteration, the algorithm 
			will produce all of the permutations that end with the element 	
			that has just been moved to the "last" position.

		Implemenation:
			algorithm Heaps(n, A):
			//Outputs all the permutations of A using Heap's algorithm
			//Input: A is a set, n is the cardinality of the set A
			//Output: The permutations of A
	    if n = 1 then
	          output(A)
	    else
	        for i ← 1 to n
	            Heaps(n - 1, A)
	            if n is odd then
	                j ← 1
	            else
	                j ← i
	            swap(A[j], A[n])
	            i ← i + 1

		Correctness
			Given an array Elements[n] with n elements
			Proof follows by induction.
			A(1) is obviously true, a one element set is sorted.
			Assume A(n) for all n >= 1.
			Prove for A(n+1)
			We know the solution for A(n) is distinct, and does not contain
			the element Elements[n+1]. First compute A(n), then run Heap's by
			inserting Elements[n+1] into each subset of A(n). Since each 
			subset of A(n) is distinct, and disjoint with Elements[n+1], this 
			insertion preserves the distinctness of our result and gives us 
			the correct solution to A(n+1).
		Termination
			Base case of n elements where n=1 is obviously sorted.
			At each step of Heap's, we recurse and break n down by a 
			factor of 1.
			Eventually we reach the the base case of 1 element, as n must be a 
			positive integer, so no infinite descent is possible.
		Space Complexity
		Time Complexity
	SJT:
		Explanation:
		Implemenation 
		Correctness
			It is clear that this method will generate all n!permutations on n 			elements with attendant directions once and only once. For each 			fixed permutation on the elements with particular set of 				orientation from 1 to k we move the element with it's orientation 			k + 1 in one direction through every possible position, thus 				giving each permutation on k + 1 elements with the same set of 				orientations  once and only once provided 			we 			have every permutation on k orientations once and only once. Since 			the method can be verified easily for k = 2 or 3, the induction is 			complete.
		Termination
			We start with one largest mobile element, which we have to move n 			times, until it becomes immobile(not all moves may occur 				simultaneously). At this point we have a new largest element, 				which we can move at most n-1 times until it becomes immobile. We 			will have in total during the running of this algorithm, n largest 			mobile elements, with each largest mobile elements moving one less 			time than it's predecessor. Since this is a finite number, the 				algorithm itself will always terminate in exactly n! steps. Not 			coincidentally , this is also the time complexity of the algorithm 			itself. 
		Space Complexity
		Time Complexity
Results & Analysis:
	Heap's:
		Space
		Time
		Additional Notes
	SJT:
		Space
		Time
		Additional Notes
		
Conclusion:
	Time and space trade-off's of the two, specific applications where one might be better than the other, 
	or is one generally better? 
	Limitations

References:
	General:
		Sedgewick, Robert (1977), "Permutation generation methods", ACM Comput. 		Surv. 9 (2): 137–164, doi:10.1145/356689.356692
		D. H. Lehmer(1960) "Proceedings of Symposia in Applied Mathematics",(American 		Mathematical Society, Vol. 10, p. 179


	SJT:
	
	Johnson, Selmer M. (1963), "Generation of permutations by adjacent transposition", 	Mathematics of Computation 17: 282–285, doi:10.1090/S0025-5718-1963-0159764-2, 		JSTOR 2003846, MR 0159764

	Heap's:
		Heap, B. R. (1963). "Permutations by Interchanges". The Computer Journal 6 		(3): 293–4. doi:10.1093/comjnl/6.3.293


