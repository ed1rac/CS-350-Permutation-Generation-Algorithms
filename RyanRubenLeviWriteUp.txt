Design and Analysis of Two Algorithms for Generating Permutations of a Set
	by Ryan Bernstein
	   Ruben Niculcea
	   Levi Schoen

CS 350
Winter 2015

Project Abstract:
	A formal mathematical analysis of two algorithms-Heap's,
	 and Steinhaus-Johnson-Trotter -for generating permutations 
	of a set. Implementation, execution  and analysis of space 
	and time performance of these two algorithms in Python. 
	Additional consideration is given to the nature of generating 
	permutations, and how these two algorithms differ in solving that problem.

Area of Analysis:
	Talk about the general class of generating permutations.
	Different methods: loopless, recursive, adjacent exchanges, factorial counting
	The last point is a simple rehash of R. Sedgewick's paper.....
	Problem Bottlenecks 

Methods:
	Heap's:
		Explanation:
			// WIP
			Heap's algorithm is a permutation generation algorithm. It works
			by recursively calling itself and at the end of each recursion is
			swaps either the first or the last element.

			// Wikipedia
			First we set a counter i  to 1. Now we perform the following steps 
			repeatedly, until i  is bigger than N. We use the algorithm to 	
			generate the (N − 1)! permutations of the first N − 1 elements, 
			adjoining the last element to each of these. This generates all of 
			the permutations that end with the last element. Then if N is odd, 
			we switch the first element and the last one, while if N is even 
			we can switch the i th element and the last one (there is no 
			difference between N even and odd in the first iteration). We add 
			one to the counter i and repeat. In each iteration, the algorithm 
			will produce all of the permutations that end with the element 	
			that has just been moved to the "last" position.

		Implemenation:
			algorithm Heaps(n, A):
			//Outputs all the permutations of A using Heap's algorithm
			//Input: A is a set, n is the cardinality of the set A
			//Output: The permutations of A
	    if n = 1 then
	          output(A)
	    else
	        for i ← 1 to n
	            Heaps(n - 1, A)
	            if n is odd then
	                j ← 1
	            else
	                j ← i
	            swap(A[j], A[n])
	            i ← i + 1

		Correctness
			Given an array Elements[n] with n elements
			Proof follows by induction.
			A(1) is obviously true, a one element set is sorted.
			Assume A(n) for all n >= 1.
			Prove for A(n+1)
			We know the solution for A(n) is distinct, and does not contain
			the element Elements[n+1]. First compute A(n), then run Heap's by
			inserting Elements[n+1] into each subset of A(n). Since each 
			subset of A(n) is distinct, and disjoint with Elements[n+1], this 
			insertion preserves the distinctness of our result and gives us 
			the correct solution to A(n+1).
		Termination
			Base case of n elements where n=1 is obviously sorted.
			At each step of Heap's, we recurse and break n down by a 
			factor of 1.
			Eventually we reach the the base case of 1 element, as n must be a 
			positive integer, so no infinite descent is possible.
		Space Complexity
		Time Complexity
	SJT:
		Explanation:
		Implemenation 
		Correctness
			It is clear that this method will generate all n!permutations on n 			elements with attendant directions once and only once. For each 			fixed permutation on the elements with particular set of 				orientation from 1 to k we move the element with it's orientation 			k + 1 in one direction through every possible position, thus 				giving each permutation on k + 1 elements with the same set of 				orientations  once and only once provided 			we 			have every permutation on k orientations once and only once. Since 			the method can be verified easily for k = 2 or 3, the induction is 			complete.
		Termination
			We start with one largest mobile element, which we have to move n 			times, until it becomes immobile(not all moves may occur 				simultaneously). At this point we have a new largest element, 				which we can move at most n-1 times until it becomes immobile. We 			will have in total during the running of this algorithm, n largest 			mobile elements, with each largest mobile elements moving one less 			time than it's predecessor. Since this is a finite number, the 				algorithm itself will always terminate in exactly n! steps. Not 			coincidentally , this is also the time complexity of the algorithm 			itself. 
		Space Complexity
		Time Complexity
Results & Analysis:
	Heap's:
		Space
		Time
		Additional Notes
	SJT:
		Space
		Time
		Additional Notes
		
Conclusion:
	Time and space trade-off's of the two, specific applications where one might be better than the other, 
	or is one generally better? 
	Limitations

References:
	General:
		Robert Sedgewick, 1977, ACM, "Permutation Generation Methods
		Writing the paper (http://www.owlnet.rice.edu/~cainproj/courses/comp482/comp482PaperGuide_F07.pdf)
		Great verbal walkthrough of both methods: http://www.cs.uni.edu/~wallingf/teaching/cs3530/sessions/session15.html
	SJT:
	http://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm
	http://www.cut-the-knot.org/Curriculum/Combinatorics/JohnsonTrotter.shtml
	http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Levitin/PDF/L07-PermutationsSubsets.pdf
	http://www.ams.org/journals/mcom/1963-17-083/S0025-5718-1963-0159764-2/S0025-5718-1963-0159764-2.pdf
	Heap's:
		http://en.wikipedia.org/wiki/Heap%27s_algorithm

Notes: Extra swap for Heap's 
